class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // need to know the size of the component
        const int N = graph.size();
        parents_.resize(N);
        iota(parents_.begin(), parents_.end(), 0);
        for(int i = 0; i < N; ++i) {
            for(int j = i + 1; j < N; ++j) {
                if (graph[i][j] == 1) {
                    unite(i, j);
                }
            }
        }
        unordered_set<int> infected(initial.begin(), initial.end());
        for(int i = 0; i < N; ++i) find(i);
        unordered_map<int, int> sizes;
        unordered_map<int, vector<int>> cands;
        for(int i = 0; i < N; ++i)  {
            int ri = find(i);
            sizes[ri]++;
            if (infected.count(i)) cands[ri].push_back(i);
        }
        int save_most = -1;
        int ans = -1;
        for(auto & p : sizes) {
            if (cands[p.first].size() == 1) {
                int cand = cands[p.first].back();
                if (p.second > save_most || (p.second == save_most && cand < ans) ) {
                    ans = cand;
                    save_most = p.second;
                }
            }
        }
        return save_most == -1 ? (*min_element(initial.begin(), initial.end())) : ans;
    }
    
private:

    int find(int x) {
        return parents_[x] == x ? x : parents_[x] = find(parents_[x]);
    }
    
    void unite(int x, int y) {
        int rx = find(x), ry = find(y);
        if (rx != ry) {
            parents_[rx] = ry;
        }
    }

    vector<int> parents_;
};
